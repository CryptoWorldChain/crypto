/* DO NOT EDIT THIS FILE - it is machine generated */
#include "icrypto_jni.h"
#include "icrypto.h"
#include "hash-library/sha256.h"
#include "hash-library/sha3.h"
#include "hash-library/md5.h"
#include "hash-library/keccak.h"


#define RELEASE_ARRAY(__arr,j__arr)  if(j__arr!=NULL){ env->ReleaseByteArrayElements(__arr, j__arr, JNI_ABORT); }

typedef unsigned char byte;
/*
 * Class:     org_brewchain_core_crypto_jni_IPPCrypto
 * Method:    init
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_org_brewchain_core_crypto_jni_IPPCrypto_init
  (JNIEnv *, jobject){

  	printf("init!!");

  }

/*
 * Class:     org_brewchain_core_crypto_jni_IPPCrypto
 * Method:    genKeys
 * Signature: ([B[B[B)V
 */
JNIEXPORT void JNICALL Java_org_brewchain_core_crypto_jni_IPPCrypto_genKeys
  (JNIEnv *env, jobject obj,jbyteArray s, jbyteArray p, jbyteArray x, jbyteArray y){


	ICKeyPair256 kp;
	int len = 0;
	jbyte* js = NULL;
	if(s!=NULL){
		len = env->GetArrayLength(s) / 4;
		if(len>0)
		{
			js = env->GetByteArrayElements(s, 0);
		}
	}
  	genKeyPair(&kp,len,(Ipp32u*)js);

	env->SetByteArrayRegion(p, 0,32	,(jbyte*)kp.p);
	env->SetByteArrayRegion(x, 0,32	,(jbyte*)kp.x);
	env->SetByteArrayRegion(y, 0,32	,(jbyte*)kp.y);

  RELEASE_ARRAY(s,js);
  }

JNIEXPORT jboolean JNICALL Java_org_brewchain_core_crypto_jni_IPPCrypto_fromPrikey
  (JNIEnv *env, jobject obj, jbyteArray p, jbyteArray x, jbyteArray y){

	ICKeyPair256 kp;
  	jbyte* jp =env->GetByteArrayElements(p, 0);
  	memcpy(kp.p,jp,32);

   	if(fromPriKey(&kp))
	{
		env->SetByteArrayRegion(x, 0,32	,(jbyte*)kp.x);
		env->SetByteArrayRegion(y, 0,32	,(jbyte*)kp.y);
    RELEASE_ARRAY(p,jp);
		return true;
	}else{
    RELEASE_ARRAY(p,jp);
		return false;
	}

  }
/*
 * Class:     org_brewchain_core_crypto_jni_IPPCrypto
 * Method:    signMessage
 * Signature: ([B[B[BLjava/lang/String;[B[B)Z
 */
JNIEXPORT jboolean JNICALL Java_org_brewchain_core_crypto_jni_IPPCrypto_signMessage
  (JNIEnv *env, jobject obj, jbyteArray p, jbyteArray x, jbyteArray y, jbyteArray msg, jbyteArray s, jbyteArray a){
  	
  	
  	jbyte* jp =env->GetByteArrayElements(p, 0);
	  jbyte* jx =env->GetByteArrayElements(x, 0);
  	jbyte* jy =env->GetByteArrayElements(y, 0);
  	jbyte* jmsg = env->GetByteArrayElements(msg, 0);
  	ICKeyPair256 kp;
  	memcpy(kp.p,jp,32);
  	memcpy(kp.x,jx,32);
  	memcpy(kp.y,jy,32);
  	if(signMessage(&kp,(Ipp8u*)jmsg)){
  		env->SetByteArrayRegion(s, 0,32	,(jbyte*)kp.s);
		  env->SetByteArrayRegion(a, 0,32	,(jbyte*)kp.a);
      RELEASE_ARRAY(p,jp);
      RELEASE_ARRAY(x,jx);
      RELEASE_ARRAY(y,jy);
      RELEASE_ARRAY(msg,jmsg);
  		return true;
  	}

      RELEASE_ARRAY(p,jp);
      RELEASE_ARRAY(x,jx);
      RELEASE_ARRAY(y,jy);
      RELEASE_ARRAY(msg,jmsg);


	return false;
  }

/*
 * Class:     org_brewchain_core_crypto_jni_IPPCrypto
 * Method:    verifyMessage
 * Signature: ([B[BLjava/lang/String;[B[B)Z
 */
JNIEXPORT jboolean JNICALL Java_org_brewchain_core_crypto_jni_IPPCrypto_verifyMessage
  (JNIEnv *env, jobject obj, jbyteArray x, jbyteArray y, jbyteArray msg, jbyteArray s, jbyteArray a){


  	jbyte* jx =env->GetByteArrayElements(x, 0);
  	jbyte* jy =env->GetByteArrayElements(y, 0);
  	jbyte* js =env->GetByteArrayElements(s, 0);
  	jbyte* ja =env->GetByteArrayElements(a, 0);
  	jbyte* jmsg = env->GetByteArrayElements(msg, 0);
  	ICKeyPair256 kp;
  	memcpy(kp.x,jx,32);
  	memcpy(kp.y,jy,32);
  	memcpy(kp.s,js,32);
  	memcpy(kp.a,ja,32);
  	if(verifyMessage(&kp,(Ipp8u*)jmsg)){

      RELEASE_ARRAY(x,jx);
      RELEASE_ARRAY(y,jy);
      RELEASE_ARRAY(s,js);
      RELEASE_ARRAY(a,ja);
      RELEASE_ARRAY(msg,jmsg);

  		return true;
  	}
    RELEASE_ARRAY(x,jx);
    RELEASE_ARRAY(y,jy);
    RELEASE_ARRAY(s,js);
    RELEASE_ARRAY(a,ja);
    RELEASE_ARRAY(msg,jmsg);


	return false;

  }


JNIEXPORT jstring JNICALL Java_org_brewchain_core_crypto_jni_IPPCrypto_sha3
  (JNIEnv *env, jobject obj, jbyteArray x){
    jbyte* jx =env->GetByteArrayElements(x, 0);
    int len = env->GetArrayLength(x);
    if(jx!=NULL&&len>0){
      SHA3 sha3;
      std::string v = sha3(jx,len);
      RELEASE_ARRAY(x,jx);
      return env->NewStringUTF( v.c_str());
    }
    RELEASE_ARRAY(x,jx);
  return  env->NewStringUTF( "");

  }


JNIEXPORT jstring JNICALL Java_org_brewchain_core_crypto_jni_IPPCrypto_sha256
  (JNIEnv *env, jobject obj, jbyteArray x){
    jbyte* jx =env->GetByteArrayElements(x, 0);
    int len = env->GetArrayLength(x);
    if(jx!=NULL&&len>0){
      SHA256 sha256;
      std::string v = sha256(jx,len);
      RELEASE_ARRAY(x,jx);
      return env->NewStringUTF( v.c_str());
    }
    RELEASE_ARRAY(x,jx);
  return  env->NewStringUTF( "");

  }

JNIEXPORT jstring JNICALL Java_org_brewchain_core_crypto_jni_IPPCrypto_md5
  (JNIEnv *env, jobject obj, jbyteArray x){
    jbyte* jx =env->GetByteArrayElements(x, 0);
    int len = env->GetArrayLength(x);
    if(jx!=NULL&&len>0){
      MD5 md5;
      std::string v = md5(jx,len);
      RELEASE_ARRAY(x,jx);
      return env->NewStringUTF(v.c_str());
    }
    RELEASE_ARRAY(x,jx);
  return  env->NewStringUTF("");

  }

JNIEXPORT jstring JNICALL Java_org_brewchain_core_crypto_jni_IPPCrypto_keccak
  (JNIEnv *env, jobject obj, jbyteArray x){
    jbyte* jx =env->GetByteArrayElements(x, 0);
    int len = env->GetArrayLength(x);
    if(jx!=NULL&&len>0){
      Keccak keccak;
      std::string v = keccak(jx,len);
      RELEASE_ARRAY(x,jx);
      return env->NewStringUTF( v.c_str());
    }
    RELEASE_ARRAY(x,jx);
  return  env->NewStringUTF("");

  }



JNIEXPORT jboolean JNICALL Java_org_brewchain_core_crypto_jni_IPPCrypto_bsha3
  (JNIEnv *env, jobject obj, jbyteArray x, jbyteArray o){
    jbyte* jx =env->GetByteArrayElements(x, 0);
    int len = env->GetArrayLength(x);
    int dlen = env->GetArrayLength(o);
    if(jx!=NULL&&len>0&&dlen>0){
      SHA3 sha3;
      unique_ptr<byte[]> d(new byte[dlen]);
      sha3(jx,len,d.get(),dlen);
      env->SetByteArrayRegion(o, 0,dlen ,(jbyte*)d.get());
      RELEASE_ARRAY(x,jx);
      return true;
    }
    RELEASE_ARRAY(x,jx);
    return false;
}


JNIEXPORT jboolean JNICALL Java_org_brewchain_core_crypto_jni_IPPCrypto_bsha256
  (JNIEnv *env, jobject obj, jbyteArray x, jbyteArray o){
    jbyte* jx =env->GetByteArrayElements(x, 0);
    int len = env->GetArrayLength(x);
    int dlen = env->GetArrayLength(o);
    if(jx!=NULL&&len>0&&dlen==32){

      unique_ptr<byte[]> d(new byte[dlen]);
      SHA256 sha256;
      sha256(jx,len,d.get(),dlen);
      // ippSHA256((Ipp8u *)jx,len,(Ipp8u *)d.get());
      env->SetByteArrayRegion(o, 0, dlen ,(jbyte*)d.get());
      RELEASE_ARRAY(x,jx);
      return true;
    }
    RELEASE_ARRAY(x,jx);
    return false;
}
JNIEXPORT jboolean JNICALL Java_org_brewchain_core_crypto_jni_IPPCrypto_bmd5
  (JNIEnv *env, jobject obj, jbyteArray x, jbyteArray o){
    jbyte* jx =env->GetByteArrayElements(x, 0);
    int len = env->GetArrayLength(x);
    int dlen = env->GetArrayLength(o);
    if(jx!=NULL&&len>0&&dlen>0){
      MD5 md5;
      unique_ptr<byte[]> d(new byte[dlen]);
      md5(jx,len,d.get(),dlen);
      env->SetByteArrayRegion(o, 0,dlen ,(jbyte*)d.get());
      RELEASE_ARRAY(x,jx);
      return true;
    }
    RELEASE_ARRAY(x,jx);
    return false;
}
JNIEXPORT jboolean JNICALL Java_org_brewchain_core_crypto_jni_IPPCrypto_bkeccak
  (JNIEnv *env, jobject obj, jbyteArray x, jbyteArray o){
    jbyte* jx =env->GetByteArrayElements(x, 0);
    int len = env->GetArrayLength(x);
    int dlen = env->GetArrayLength(o);
    if(jx!=NULL&&len>0&&dlen>0){
      Keccak keccak;
      unique_ptr<byte[]> d(new byte[dlen]);
      keccak(jx,len,d.get(),dlen);
      env->SetByteArrayRegion(o, 0,dlen ,(jbyte*)d.get());
      RELEASE_ARRAY(x,jx);
      return true;
    }
    RELEASE_ARRAY(x,jx);
    return false;
}
